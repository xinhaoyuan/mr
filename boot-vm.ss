;; == PROG ====================================================
(define (vm-prog:trace prog id)
  (vector-ref (car prog) id))
(define (vm-prog:entry-id prog)
  (cdr prog))

;; == TRACE ===================================================
(define (vm-trace:create lambda-info instruction-size constant-size)
  (vector
   lambda-info
   (make-vector instruction-size '())
   (make-vector constant-size '()))
  )
(define (vm-trace:lambda-info trace)
  (vector-ref trace 0))
(define (vm-trace:instruction-set! trace index instruction)
  (vector-set! (vector-ref trace 1) index instruction))
(define (vm-trace:instruction trace index)
  (vector-ref (vector-ref trace 1) index))
(define (vm-trace:instruction-size trace)
  (vector-length (vector-ref trace 1)))
(define (vm-trace:constant-set! trace index constant)
  (vector-set! (vector-ref trace 2) index constant))
(define (vm-trace:constant trace index)
  (vector-ref (vector-ref trace 2) index))
(define (vm-trace:constant-size trace)
  (vector-length (vector-ref trace 2)))

;; == INSTRUCTION =============================================
(define (vm-instruction:arg instruction n) (vector-ref instruction n))
(define vm-instruction-head:constant       'constant)
(define vm-instruction-head:load           'load)
(define vm-instruction-head:store          'store)
(define vm-instruction-head:branch         'branch)
(define vm-instruction-head:jump           'jump)
(define vm-instruction-head:lambda         'lambda)
(define vm-instruction-head:apply-prepare  'apply-prepare)
(define vm-instruction-head:apply-push-arg 'apply-push-arg)
(define vm-instruction-head:apply          'apply)
(define vm-instruction-head:apply-tail     'apply-tail)
(define vm-instruction-head:return         'return)
(define vm-instruction-code:constant       0)
(define vm-instruction-code:load           1)
(define vm-instruction-code:store          2)
(define vm-instruction-code:branch         3)
(define vm-instruction-code:jump           4)
(define vm-instruction-code:lambda         5)
(define vm-instruction-code:apply-prepare  6)
(define vm-instruction-code:apply-push-arg 7)
(define vm-instruction-code:apply          8)
(define vm-instruction-code:apply-tail     9)
(define vm-instruction-code:return         10)

(define vm-constant-head:int               1)
(define vm-constant-head:string-symbol     2)
(define vm-cosntant-head:string            3)

;; == ENVIRONMENT =============================================
(define (vm-env:binding env level offset)
  (if (> level 0)
      (vm-env:binding (cdr env) (- level 1) offset)
      (vector-ref (car env) offset)))
(define (vm-env:binding-set! env level offset value)
  (if (> level 0)
      (vm-env:binding-set! (cdr env) (- level 1) offset value)
      (vector-set! (car env) offset value)))
(define (vm-env:append env level-vec) (cons level-vec env))
(define (vm-env:create-empty) '())

;; == FRAME ===================================================
(define (vm-frame:create-empty) '())
(define (vm-frame:create prog trace pc regs env return-frame dst)
  (vector prog trace pc regs env return-frame dst))
(define (vm-frame:empty? frame)       (eq? frame '()))
(define (vm-frame:prog frame)         (vector-ref frame 0))
(define (vm-frame:trace frame)        (vector-ref frame 1))
(define (vm-frame:pc frame)           (vector-ref frame 2))
(define (vm-frame:regs frame)         (vector-ref frame 3))
(define (vm-frame:env frame)          (vector-ref frame 4))
(define (vm-frame:return-frame frame) (vector-ref frame 5))
(define (vm-frame:dst frame)          (vector-ref frame 6))

;; == CLOSURE =================================================
(define (closure:create-lambda arg-count prog entry-id regs-size env)
  (vector arg-count prog entry-id regs-size env))
(define (closure:is-lambda? x)
  (and (vector? x)
       (eq? (vector-length x) 5)))
(define (closure:lambda-arg-count closure)
  (vector-ref closure 0))
(define (closure:lambda-prog closure)
  (vector-ref closure 1))
(define (closure:lambda-entry-id closure)
  (vector-ref closure 2))
(define (closure:lambda-regs-size closure)
  (vector-ref closure 3))
(define (closure:lambda-env closure)
  (vector-ref closure 4))

;; == VM ======================================================
(define (vm:execute prog trace pc regs env return-frame)
  (letrec
      ((execute-trace
        (lambda (trace pc apply-reg)
          (let ((instruction (vm-trace:instruction trace pc)))
            ;; (display instruction) (newline)
            (let ((head (vm-instruction:arg instruction 0)))
              (cond
               ((eq? head vm-instruction-head:constant)
                (let ((const (vm-instruction:arg instruction 1))
                      (dst   (vm-instruction:arg instruction 2)))
                  (vector-set! regs dst (vm-trace:constant trace const))
                  (execute-trace trace (+ pc 1) apply-reg)
                  ))
               ((eq? head vm-instruction-head:load)
                (let ((level  (vm-instruction:arg instruction 1))
                      (offset (vm-instruction:arg instruction 2))
                      (dst    (vm-instruction:arg instruction 3)))
                  (vector-set! regs dst
                       (vm-env:binding env level offset))
                  (execute-trace trace (+ pc 1) apply-reg)
                  ))
               ((eq? head vm-instruction-head:store)
                (let ((level  (vm-instruction:arg instruction 1))
                      (offset (vm-instruction:arg instruction 2))
                      (src    (vm-instruction:arg instruction 3)))
                  (vm-env:binding-set! env level offset
                                            (vector-ref regs src))
                  (execute-trace trace (+ pc 1) apply-reg)
                  ))
               ((eq? head vm-instruction-head:branch)
                (let ((then-branch-id (vm-instruction:arg instruction 1))
                      (else-branch-id (vm-instruction:arg instruction 2))
                      (src            (vm-instruction:arg instruction 3)))
                  ;; test the condition register
                  (if (vector-ref regs src)
                      (execute-trace (vm-prog:trace prog then-branch-id) 0 apply-reg)
                      (execute-trace (vm-prog:trace prog else-branch-id) 0 apply-reg))
                  ))
               ((eq? head vm-instruction-head:jump)
                (let ((target-id (vm-instruction:arg instruction 1)))
                  (execute-trace (vm-prog:trace prog target-id) 0 apply-reg)
                  ))
               ((eq? head vm-instruction-head:lambda)
                (let ((entry-id  (vm-instruction:arg instruction 1))
                      (dst       (vm-instruction:arg instruction 2)))
                  (let ((lambda-info (vm-trace:lambda-info (vm-prog:trace prog entry-id))))
                    (vector-set! regs dst (closure:create-lambda (vector-ref lambda-info 0) ; argc
                                                                 prog
                                                                 entry-id
                                                                 (vector-ref lambda-info 1) ; regs-size
                                                                 env))
                    (execute-trace trace (+ pc 1) apply-reg)
                    )))
               ((eq? head vm-instruction-head:apply-prepare)
                (let ((src (vm-instruction:arg instruction 1)))
                  (execute-trace trace (+ pc 1) (cons (vector-ref regs src) apply-reg))
                  ))
               ((eq? head vm-instruction-head:apply-push-arg)
                (let ((src (vm-instruction:arg instruction 1)))
                  (execute-trace trace (+ pc 1) (cons (vector-ref regs src) apply-reg))
                  ))
               ((or (eq? head vm-instruction-head:apply)
                    (eq? head vm-instruction-head:apply-tail))
                (let ((apply-list (reverse apply-reg)))
                  (let ((apply-closure (car apply-list))
                        (apply-args    (cdr apply-list)))
                    (cond
                     ((closure:is-lambda? apply-closure)
                      (let ((closure-arg-count (closure:lambda-arg-count apply-closure))
                            (closure-prog      (closure:lambda-prog      apply-closure))
                            (closure-entry-id  (closure:lambda-entry-id  apply-closure))
                            (closure-regs-size (closure:lambda-regs-size apply-closure))
                            (closure-regs     '())
                            (closure-env       (closure:lambda-env       apply-closure))
                            (frame             (if (eq? head vm-instruction-head:apply)
                                                   (vm-frame:create prog trace (+ pc 1) regs env return-frame (vm-instruction:arg instruction 1))
                                                   return-frame)))
                        (set! closure-regs (make-vector closure-regs-size '()))
                        (letrec ((level (make-vector closure-arg-count '()))
                                 (fill-level
                                  (lambda (args count)
                                    (if (and (pair? args)
                                             (< count closure-arg-count))
                                        (begin
                                          (vector-set! level count (car args))
                                          (fill-level (cdr args) (+ count 1)))
                                        (set! closure-env (vm-env:append closure-env level))))))
                          (fill-level apply-args 0))
                        (vm:execute closure-prog (vm-prog:trace closure-prog closure-entry-id) 0 closure-regs closure-env frame)
                        ))
                     (else
                      (let ((result
                             (if (symbol? apply-closure)
                                 (vm:internal-call apply-closure apply-args)
                                 '())))
                        (if (eq? head vm-instruction-head:apply)
                            (begin
                              (vector-set! regs (vm-instruction:arg instruction 1) result)
                              (execute-trace trace (+ pc 1) '()))
                            (vm:execute-frame-with-return return-frame result))
                        ))
                     ))))
               ((eq? head vm-instruction-head:return)
                (let ((src (vm-instruction:arg instruction 1)))
                  (vm:execute-frame-with-return return-frame (vector-ref regs src))
                  ))
               (else '())
               )
              )))
        ))
    (execute-trace trace pc '())
    ))
(define (vm:internal-call name args)
  (cond
   ((eq? name 'print)
    (begin (display args) (newline) '()))
   ((eq? name '+)
    (apply + args))
   ((eq? name '<)
    (apply < args))
   (else '())
   ))
(define (vm:execute-frame-with-return frame value)
  (if (vm-frame:empty? frame)
      value
      (let ((return-prog  (vm-frame:prog         frame))
            (return-trace (vm-frame:trace        frame))
            (return-pc    (vm-frame:pc           frame))
            (return-regs  (vm-frame:regs         frame))
            (return-env   (vm-frame:env          frame))
            (return-frame (vm-frame:return-frame frame))
            (return-dst   (vm-frame:dst          frame)))
        (vector-set! return-regs return-dst value)
        (vm:execute return-prog return-trace return-pc return-regs return-env return-frame)
        )))
(define (vm:execute-prog prog)
  (let ((regs (make-vector
               (vector-ref
                (vm-trace:lambda-info
                 (vm-prog:trace prog (vm-prog:entry-id prog))) 1)
               '())))
    (vm:execute prog
                (vm-prog:trace prog (vm-prog:entry-id prog))
                0
                regs
                (vm-env:create-empty)
                (vm-frame:create-empty))))

;; == IO ======================================================
(define (vm-io:write-binary prog)
  (letrec
      ((rlist '())
       (write
        (lambda (i)
          ;; (display "write ") (display i) (newline)
          (set! rlist (cons i rlist)))))
    (let ((traces (car prog)))
      (write (vector-length traces))
      (write (vm-prog:entry-id prog))
      (letrec
          ((write-trace
            (lambda (index)
              (and (< index (vector-length traces))
                   (let ((trace (vector-ref traces index)))
                     (if (eq? (vm-trace:lambda-info trace) '())
                         ;; no lambda info
                         (write 0)
                         (let ((li (vm-trace:lambda-info trace)))
                           (write 1)
                           (write (vector-ref li 0))
                           (write (vector-ref li 1))))
                     (write (vm-trace:instruction-size trace))
                     (letrec
                         ((write-instruction
                           (lambda (index)
                             (and (< index (vm-trace:instruction-size trace))
                                  (let ((ins (vm-trace:instruction trace index)))
                                    (let ((head (vm-instruction:arg ins 0)))
                                      (cond
                                       ((eq? head vm-instruction-head:constant)
                                        (let ((const (vm-instruction:arg ins 1))
                                              (dst   (vm-instruction:arg ins 2)))
                                          (write vm-instruction-code:constant)
                                          (write const)
                                          (write dst)
                                          ))
                                       ((eq? head vm-instruction-head:load)
                                        (let ((level  (vm-instruction:arg ins 1))
                                              (offset (vm-instruction:arg ins 2))
                                              (dst    (vm-instruction:arg ins 3)))
                                          (write vm-instruction-code:load)
                                          (write level)
                                          (write offset)
                                          (write dst)
                                          ))
                                       ((eq? head vm-instruction-head:store)
                                        (let ((level  (vm-instruction:arg ins 1))
                                              (offset (vm-instruction:arg ins 2))
                                              (src    (vm-instruction:arg ins 3)))
                                          (write vm-instruction-code:store)
                                          (write level)
                                          (write offset)
                                          (write src)
                                          ))
                                       ((eq? head vm-instruction-head:branch)
                                        (let ((then-branch-id (vm-instruction:arg ins 1))
                                              (else-branch-id (vm-instruction:arg ins 2))
                                              (src            (vm-instruction:arg ins 3)))
                                          (write vm-instruction-code:branch)
                                          (write then-branch-id)
                                          (write else-branch-id)
                                          (write src)
                                          ))
                                       ((eq? head vm-instruction-head:jump)
                                        (let ((target-id (vm-instruction:arg ins 1)))
                                          (write vm-instruction-code:jump)
                                          (write target-id)
                                          ))
                                       ((eq? head vm-instruction-head:lambda)
                                        (let ((entry-id  (vm-instruction:arg ins 1))
                                              (dst       (vm-instruction:arg ins 2)))
                                          (write vm-instruction-code:lambda)
                                          (write entry-id)
                                          (write dst)
                                          ))
                                       ((eq? head vm-instruction-head:apply-prepare)
                                        (let ((src (vm-instruction:arg ins 1)))
                                          (write vm-instruction-code:apply-prepare)
                                          (write src)
                                          ))
                                       ((eq? head vm-instruction-head:apply-push-arg)
                                        (let ((src (vm-instruction:arg ins 1)))
                                          (write vm-instruction-code:apply-push-arg)
                                          (write src)
                                          ))
                                       ((eq? head vm-instruction-head:apply)
                                        (let ((dst (vm-instruction:arg ins 1)))
                                          (write vm-instruction-code:apply)
                                          (write dst)
                                          ))
                                        ((eq? head vm-instruction-head:apply-tail)
                                         (write vm-instruction-code:apply-tail)
                                         )
                                       ((eq? head vm-instruction-head:return)
                                        (let ((src (vm-instruction:arg ins 1)))
                                          (write vm-instruction-code:return)
                                          (write src)
                                          ))
                                       (else '())
                                       )
                                      )
                                    (write-instruction (+ index 1))
                                    )))))
                       (write-instruction 0))
                     (write (vm-trace:constant-size trace))
                     (letrec
                         ((write-constant
                           (lambda (index)
                             (and (< index (vm-trace:constant-size trace))
                                  (let ((const (vm-trace:constant trace index)))
                                    (write (format "~v" const))
                                    (write-constant (+ index 1))
                                    )))))
                       (write-constant 0))
                     (write-trace (+ index 1))
                     )))))
        (write-trace 0)
        ))
    (list->vector (reverse rlist))
    ))
    
;; == UNIT TEST ===============================================
(define vm:unit-case-1
  '( #( #( #( 0 2 )
           #( #(constant 0 0)
              #(constant 1 1)
              #(apply-prepare 0)
              #(apply-push-arg 1)
              #(apply 0)
              #(return 0)
              )
           #( print 1024 )
           )
        )
     . 0)
  )
(define vm:unit-case-2
  '( #( #( #( 0 4 )
           #( #(constant 0 0)
              #(constant 1 1)
              #(constant 2 2)
              #(constant 3 3)
              #(apply-prepare 0)
              #(apply-push-arg 1)
              #(apply-push-arg 2)
              #(apply-push-arg 3)
              #(apply 0)
              #(constant 4 3)
              #(apply-prepare 3)
              #(apply-push-arg 0)
              #(apply-tail)
              )
           #( + 1 2 1000 print )
           )
        )
     . 0)
  )
(define vm:unit-case-3
  '( #( #( #(0 4)
           #( #(constant 0 0)
              #(constant 1 1)
              #(constant 2 2)
              #(constant 3 3)
              #(apply-prepare 0)
              #(apply-push-arg 1)
              #(apply-push-arg 2)
              #(apply-push-arg 3)
              #(apply 0)
              #(jump 1)
              )
           #( + 1 2 1000 )
           )
        #( ()
           #( #(constant 0 3)
              #(apply-prepare 3)
              #(apply-push-arg 0)
              #(apply 0)
              #(return 0)
              )
           #( print )
           )
        )
     . 0)
  )
(define vm:unit-case-4
  '( #( #( #(0 4)
           #( #(constant 0 0)
              #(branch 1 2 0)
              )
           #( #f )
           )
        #( ()
           #( #(constant 0 0)
              #(constant 1 1)
              #(constant 2 2)
              #(constant 3 3)
              #(apply-prepare 0)
              #(apply-push-arg 1)
              #(apply-push-arg 2)
              #(apply-push-arg 3)
              #(apply 0)
              #(jump 2)
              )
           #( + 1 2 1000 )
           )
        #( ()
           #( #(constant 0 3)
              #(apply-prepare 3)
              #(apply-push-arg 0)
              #(apply 0)
              #(return 0)
              )
           #( print )
           )
        )
     . 0)
  )
(define vm:unit-case-5
  '( #( #( #(1 2)
           #( #(constant 0 0)
              #(load 0 0 1)
              #(apply-prepare 0)
              #(apply-push-arg 1)
              #(apply 0)
              #(constant 1 0)
              #(return 0))
           #( print 1234 )
         )
        #( #(0 2)
           #( #(constant 0 1)
              #(lambda 0 0)
              #(apply-prepare 0)
              #(apply-push-arg 1)
              #(apply 1)
              #(constant 1 0)
              #(apply-prepare 0)
              #(apply-push-arg 1)
              #(apply-tail))
           #( "Hello world" print )
           )
        )
     . 1)
  )
(define vm:unit-case-6
  '( #( #( #(2 3)
           #( #(constant 0 0)
              #(load 0 0 1)
              #(constant 1 2)
              #(apply-prepare 0)
              #(apply-push-arg 1)
              #(apply-push-arg 2)
              #(apply 0)
              #(branch 1 2 0))
           #( < 1000000 )
           )
        #( ()
           #( #(constant 0 0)
              #(constant 1 2)
              #(apply-prepare 0)
              #(apply-push-arg 1)
              #(apply-push-arg 2)
              #(apply 0)
              #(load 0 1 1)
              #(apply-prepare 1)
              #(apply-push-arg 0)
              #(apply-push-arg 1)
              #(apply-tail) )
           #( + 1 )
           )
        #( ()
           #( #(constant 0 0)
              #(apply-prepare 0)
              #(apply-push-arg 1)
              #(apply-tail))
           #( print )
           )
        #( #(0 2)
           #( #(lambda 0 0)
              #(constant 0 1)
              #(apply-prepare 0)
              #(apply-push-arg 1)
              #(apply-push-arg 0)
              #(apply-tail))
           #( 0 )
           )
        )
     . 3
     ))
(define (vm:unit-test)
  (vm:execute-prog vm:unit-case-1)
  (vm:execute-prog vm:unit-case-2)
  (vm:execute-prog vm:unit-case-3)
  (vm:execute-prog vm:unit-case-4)
  (vm:execute-prog vm:unit-case-5)
  (vm:execute-prog vm:unit-case-6)
  )
