;; == PROG ====================================================
(define (prog:trace prog id)
  (vector-ref (car prog) id))
(define (prog:entry-id prog)
  (vector-ref (cdr prog) 0))
(define (prog:entry-regs-size prog)
  (vector-ref (cdr prog) 1))

;; == TRACE ===================================================
(define (trace:create size)
  (make-vector size '()))
(define (trace:instruction-set! trace index instruction)
  (vector-set! trace index instruction))
(define (trace:instruction trace index)
  (vector-ref trace index))
(define (trace:length trace)
  (vector-length trace))

;; == INSTRUCTION =============================================
(define (instruction:arg instruction n) (vector-ref instruction n))
(define instruction-head:constant       'constant)
(define instruction-head:load           'load)
(define instruction-head:store          'store)
(define instruction-head:if             'if)
(define instruction-head:goto           'goto)
(define instruction-head:lambda         'lambda)
(define instruction-head:apply-prepare  'apply-prepare)
(define instruction-head:apply-push-arg 'apply-push-arg)
(define instruction-head:apply          'apply)
(define instruction-head:apply-tail     'apply-tail)
(define instruction-head:return         'return)

;; == ENVIRONMENT =============================================
(define (environment:binding env level offset)
  (if (> level 0)
      (environment:binding (cdr env) (- level 1) offset)
      (vector-ref (car env) offset)))
(define (environment:binding-set! env level offset value)
  (if (> level 0)
      (environment:binding-set! (cdr env) (- level 1) offset value)
      (vector-set! (car env) offset value)))
(define (environment:append env level-vec) (cons level-vec env))
(define (environment:create-empty) '())

;; == FRAME ===================================================
(define (frame:create-empty) '())
(define (frame:create prog trace pc regs env return-frame dst)
  (vector prog trace pc regs env return-frame dst))
(define (frame:empty? frame)       (eq? frame '()))
(define (frame:prog frame)         (vector-ref frame 0))
(define (frame:trace frame)        (vector-ref frame 1))
(define (frame:pc frame)           (vector-ref frame 2))
(define (frame:regs frame)         (vector-ref frame 3))
(define (frame:env frame)          (vector-ref frame 4))
(define (frame:return-frame frame) (vector-ref frame 5))
(define (frame:dst frame)          (vector-ref frame 6))

;; == CLOSURE =================================================
(define (closure:create-lambda arg-count prog entry-id regs-size env)
  (vector arg-count prog entry-id regs-size env))
(define (closure:is-lambda? x)
  (and (vector? x)
       (eq? (vector-length x) 5)))
(define (closure:lambda-arg-count closure)
  (vector-ref closure 0))
(define (closure:lambda-prog closure)
  (vector-ref closure 1))
(define (closure:lambda-entry-id closure)
  (vector-ref closure 2))
(define (closure:lambda-regs-size closure)
  (vector-ref closure 3))
(define (closure:lambda-env closure)
  (vector-ref closure 4))

;; == VM ======================================================
(define (vm:execute prog trace pc regs env return-frame)
  (letrec
      ((execute-trace
        (lambda (trace pc apply-reg)
          (let ((instruction (trace:instruction trace pc)))
            ;; (display instruction) (newline)
            (let ((head (instruction:arg instruction 0)))
              (cond
               ((eq? head instruction-head:constant)
                (let ((const (instruction:arg instruction 1))
                      (dst   (instruction:arg instruction 2)))
                  (vector-set! regs dst const)
                  (execute-trace trace (+ pc 1) apply-reg)
                  ))
               ((eq? head instruction-head:load)
                (let ((level  (instruction:arg instruction 1))
                      (offset (instruction:arg instruction 2))
                      (dst    (instruction:arg instruction 3)))
                  (vector-set! regs dst
                       (environment:binding env level offset))
                  (execute-trace trace (+ pc 1) apply-reg)
                  ))
               ((eq? head instruction-head:store)
                (let ((level  (instruction:arg instruction 1))
                      (offset (instruction:arg instruction 2))
                      (src    (instruction:arg instruction 3)))
                  (environment:binding-set! env level offset
                                            (vector-ref regs src))
                  (execute-trace trace (+ pc 1) apply-reg)
                  ))
               ((eq? head instruction-head:if)
                (let ((then-branch-id (instruction:arg instruction 1))
                      (else-branch-id (instruction:arg instruction 2))
                      (src            (instruction:arg instruction 3)))
                  ;; test the condition register
                  (if (vector-ref regs src)
                      (execute-trace (prog:trace prog then-branch-id) 0 apply-reg)
                      (execute-trace (prog:trace prog else-branch-id) 0 apply-reg))
                  ))
               ((eq? head instruction-head:goto)
                (let ((target-id (instruction:arg instruction 1)))
                  (execute-trace (prog:trace prog target-id) 0 apply-reg)
                  ))
               ((eq? head instruction-head:lambda)
                (let ((arg-count (instruction:arg instruction 1))
                      (entry-id  (instruction:arg instruction 2))
                      (regs-size (instruction:arg instruction 3))
                      (dst       (instruction:arg instruction 4)))
                  (vector-set! regs dst (closure:create-lambda arg-count prog entry-id regs-size env))
                  (execute-trace trace (+ pc 1) apply-reg)
                  ))
               ((eq? head instruction-head:apply-prepare)
                (let ((src (instruction:arg instruction 1)))
                  (execute-trace trace (+ pc 1) (cons (vector-ref regs src) apply-reg))
                  ))
               ((eq? head instruction-head:apply-push-arg)
                (let ((src (instruction:arg instruction 1)))
                  (execute-trace trace (+ pc 1) (cons (vector-ref regs src) apply-reg))
                  ))
               ((or (eq? head instruction-head:apply)
                    (eq? head instruction-head:apply-tail))
                (let ((apply-list (reverse apply-reg)))
                  (let ((apply-closure (car apply-list))
                        (apply-args    (cdr apply-list)))
                    (cond
                     ((closure:is-lambda? apply-closure)
                      (let ((closure-arg-count (closure:lambda-arg-count apply-closure))
                            (closure-prog      (closure:lambda-prog      apply-closure))
                            (closure-entry-id  (closure:lambda-entry-id  apply-closure))
                            (closure-regs-size (closure:lambda-regs-size apply-closure))
                            (closure-regs     '())
                            (closure-env       (closure:lambda-env       apply-closure))
                            (frame             (if (eq? head instruction-head:apply)
                                                   (frame:create prog trace (+ pc 1) regs env return-frame (instruction:arg instruction 1))
                                                   return-frame)))
                        (set! closure-regs (make-vector closure-regs-size '()))
                        (letrec ((level (make-vector closure-arg-count '()))
                                 (fill-level
                                  (lambda (args count)
                                    (if (and (pair? args)
                                             (< count closure-arg-count))
                                        (begin
                                          (vector-set! level count (car args))
                                          (fill-level (cdr args) (+ count 1)))
                                        (set! closure-env (environment:append closure-env level))))))
                          (fill-level apply-args 0))
                        (vm:execute closure-prog (prog:trace closure-prog closure-entry-id) 0 closure-regs closure-env frame)
                        ))
                     (else
                      (let ((result
                             (if (symbol? apply-closure)
                                 (vm:internal-call apply-closure apply-args)
                                 '())))
                        (if (eq? head instruction-head:apply)
                            (begin
                              (vector-set! regs (instruction:arg instruction 1) result)
                              (execute-trace trace (+ pc 1) '()))
                            (vm:execute-frame-with-return return-frame result))
                        ))
                     ))))
               ((eq? head instruction-head:return)
                (let ((src (instruction:arg instruction 1)))
                  (vm:execute-frame-with-return return-frame (vector-ref regs src))
                  ))
               (else '())
               )
              )))
        ))
    (execute-trace trace pc '())
    ))
(define (vm:internal-call name args)
  (cond
   ((eq? name 'print)
    (begin (display args) (newline) '()))
   ((eq? name '+)
    (apply + args))
   ((eq? name '<)
    (apply < args))
   (else '())
   ))
(define (vm:execute-frame-with-return frame value)
  (if (frame:empty? frame)
      value
      (let ((return-prog  (frame:prog         frame))
            (return-trace (frame:trace        frame))
            (return-pc    (frame:pc           frame))
            (return-regs  (frame:regs         frame))
            (return-env   (frame:env          frame))
            (return-frame (frame:return-frame frame))
            (return-dst   (frame:dst          frame)))
        (vector-set! return-regs return-dst value)
        (vm:execute return-prog return-trace return-pc return-regs return-env return-frame)
        )))
(define (vm:execute-prog prog)
  (let ((regs (make-vector (prog:entry-regs-size prog) '())))
    (vm:execute prog
                (prog:trace prog (prog:entry-id prog))
                0
                regs
                (environment:create-empty)
                (frame:create-empty))))

;; == UNIT TEST ===============================================
(define vm:unit-case-1
  '( #( #( #(constant print 0)
           #(constant 1024  1)
           #(apply-prepare 0)
           #(apply-push-arg 1)
           #(apply 0)
           #(return 0)
           )
        )
     . #(0 2))
  )
(define vm:unit-case-2
  '( #( #( #(constant + 0)
           #(constant 1 1)
           #(constant 2 2)
           #(constant 1000 3)
           #(apply-prepare 0)
           #(apply-push-arg 1)
           #(apply-push-arg 2)
           #(apply-push-arg 3)
           #(apply 0)
           #(constant print 3)
           #(apply-prepare 3)
           #(apply-push-arg 0)
           #(apply-tail)
           )
        )
     . #(0 4))
  )
(define vm:unit-case-3
  '( #( #( #(constant + 0)
           #(constant 1 1)
           #(constant 2 2)
           #(constant 1000 3)
           #(apply-prepare 0)
           #(apply-push-arg 1)
           #(apply-push-arg 2)
           #(apply-push-arg 3)
           #(apply 0)
           #(goto 1)
           )
        #(#(constant print 3)
           #(apply-prepare 3)
           #(apply-push-arg 0)
           #(apply 0)
           #(return 0)
           )
        )
     . #(0 4))
  )
(define vm:unit-case-4
  '( #( #( #(constant #f 0)
           #(if 1 2 0)
           )
        #( #(constant + 0)
           #(constant 1 1)
           #(constant 2 2)
           #(constant 1000 3)
           #(apply-prepare 0)
           #(apply-push-arg 1)
           #(apply-push-arg 2)
           #(apply-push-arg 3)
           #(apply 0)
           #(goto 2)
           )
        #( #(constant print 3)
           #(apply-prepare 3)
           #(apply-push-arg 0)
           #(apply 0)
           #(return 0)
           )
        )
     . #(0 4))
  )
(define vm:unit-case-5
  '( #( #( #(constant print 0)
           #(load 0 0 1)
           #(apply-prepare 0)
           #(apply-push-arg 1)
           #(apply 0)
           #(constant 1234 0)
           #(return 0))
        #( #(constant "Hello world" 1)
           #(lambda 1 0 2 0)
           #(apply-prepare 0)
           #(apply-push-arg 1)
           #(apply 1)
           #(constant print 0)
           #(apply-prepare 0)
           #(apply-push-arg 1)
           #(apply-tail))
        )
     . #(1 2))
  )
(define vm:unit-case-6
  '( #( #( #(constant < 0)
           #(load 0 0 1)
           #(constant 1000000 2)
           #(apply-prepare 0)
           #(apply-push-arg 1)
           #(apply-push-arg 2)
           #(apply 0)
           #(if 1 2 0))
        #( #(constant + 0)
           #(constant 1 2)
           #(apply-prepare 0)
           #(apply-push-arg 1)
           #(apply-push-arg 2)
           #(apply 0)
           #(load 0 1 1)
           #(apply-prepare 1)
           #(apply-push-arg 0)
           #(apply-push-arg 1)
           #(apply-tail) )
        #( #(constant print 0)
           #(apply-prepare 0)
           #(apply-push-arg 1)
           #(apply-tail))
        #( #(lambda 2 0 3 0)
           #(constant 0 1)
           #(apply-prepare 0)
           #(apply-push-arg 1)
           #(apply-push-arg 0)
           #(apply-tail))
        )
     . #(3 2)
     ))
(define (vm:unit-test)
  (vm:execute-prog vm:unit-case-1)
  (vm:execute-prog vm:unit-case-2)
  (vm:execute-prog vm:unit-case-3)
  (vm:execute-prog vm:unit-case-4)
  (vm:execute-prog vm:unit-case-5)
  (vm:execute-prog vm:unit-case-6)
  )
